<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Curve Vertex and Noise</title>
  <!-- CSS Reset -->
  <link rel="stylesheet" href="https://unpkg.com/modern-css-reset/dist/reset.min.css" />
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link
    href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300&family=Montserrat:wght@600;800&family=Work+Sans:wght@300;400;500&display=swap"
    rel="stylesheet">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/stackoverflow-dark.min.css">
  <link rel="stylesheet" href="../../css/styles.css" type="text/css">
</head>

<body>
  <main>
    <section id="sketch"></section>
    <article>
      <header>
        <h3>Curve Vertex and Noise</h3>
        <span class="sketch-info">
          Using other built in functions of the p5.js library to draw a circle. Perlin Noise is also applied to generate
          the above shape.
        </span>
      </header>
      <h4>Creating the points</h4>
      <p>
        An object or point created from the class <code>Point</code> has a single initial property that
        describes its x and y positions on the canvas. This is stored in a vector.
      </p>
<pre><code class="language-js">class Point {
  constructor(_x, _y) {
    this.coordinates = createVector(_x, _y);
  }
}</code></pre>
      <p>
        To set the initial positions of each point for drawing the circle, the angle is varied and trigonometry is used
        to calculate where the x and y position of the point would be for that angle. x would be <code>cos(angle)</code> and y would be <code>sin(angle)</code>.
        These values are multipled by the radius as the circle is large. Each point object is stored in an array.
      </p>
<pre><code class="language-js">let numOfSegments = 180;
let points = [];
let radius, angle;

function setup() {
  [...]
  radius = 150;
  angle = radians(360/numOfSegments);
  for (let i = 0; i < numOfSegments; i++) {
    let xPos = radius * cos(angle*i);
    let yPos = radius * sin(angle*i);
    points.push(new Point(xPos, yPos));
  }
}</code></pre>
      <h4>Drawing points around a circle</h4>
      <p>
        The method <code>drawEllipse()</code> is called on each point object, which draws a small ellipse on the canvas.
      </p>
<pre><code class="language-js">class Point {
  [...]
  drawEllipse() {
    noStroke();
    fill('#00C2BA');
    ellipse(this.coordinates.x, this.coordinates.y, 5);
  }
}

function draw() {
  background('#000');
  push();
  // Move origin to the centre
  translate(width/2, height/2);
  points.forEach(point => {
    point.drawEllipse();
  });
  pop();
}</code></pre>
      <p>In the example below, the circle is made up of 12 segments or has 12 points around it.</p>
      <figure>
        <img src="images/drawEllipse.png" alt="Points around a circle">
      </figure>
      <h4>Using line() to draw a circle</h4>
      <p>
        Another way of creating a circle is by using the <code>line()</code> method. The <code>drawLine()</code> method of class <code>Point</code>
        takes an index number. This method draws a line starting from the x and y points of the point object calling it
        to the x and y positions of the point that matches the index number passed to the method. The <code>drawLines()</code> function takes an array
        and draws the lines that will form the circle.
      </p>
<pre><code class="language-js">class Point {
  [...]
  drawLine(_index) {
    stroke('#00C2BA');
    line(this.coordinates.x, this.coordinates.y, points[_index].coordinates.x, points[_index].coordinates.y);
  }
}

function draw() {
  [...]
  drawLines(points);
  pop();
}

function drawLines(_array) {
  for (let i = 0; i < _array.length - 1; i++) {
    _array[i].drawLine(i+1);
  }
  line(_array[_array.length-1].coordinates.x, _array[_array.length-1].coordinates.y,
    _array[0].coordinates.x, _array[0].coordinates.y);
}</code></pre>
      <p>
        In the example below, there are only 12 segments of the shape making it look like a twelve-sided polygon.
      </p>
      <figure>
        <img src="images/drawLines1.png" alt="Draw Lines 1">
      </figure>
      <p>
        The higher the amount of segments is, the closer the shape resembles a circle. In the image below, the 
        shape is made up of 180 segments.
      </p>
      <figure>
        <img src="images/drawLines2.png" alt="Draw Lines 2">
      </figure>
      <h4>Using curveVertex() to draw a circle</h4>
      <p>
        The <code>curveVertex()</code> method is used in conjunction with <code>beginShape()</code> and <code>endShape()</code>. The 
        <code>drawCurveVertex()</code> method creates a vertex coordinate for the circle. The <code>drawCurveVertices()</code> function
        draws the curve vertex coordinates taken from an array and these values will form the circle. The first and last curve vertex points guide
        the beginning and end of the curve.
      </p>
<pre><code class="language-js">class Point {
  [...]
  drawCurveVertex() {
    curveVertex(this.coordinates.x, this.coordinates.y);
  }
}

function draw() {
  [...]
  drawCurveVertices(points);
  pop();
}

function drawCurveVertices(_array) {
  noFill();
  stroke(color);
  beginShape();
  // first controlled points
  curveVertex(_array[_array.length-1].coordinates.x, _array[_array.length-1].coordinates.y);
  curveVertex(_array[_array.length-1].coordinates.x, _array[_array.length-1].coordinates.y);
  _array.forEach(item => {
      item.drawCurveVertex();
  });
  // last controlled points
  curveVertex(_array[0].coordinates.x, _array[0].coordinates.y);
  curveVertex(_array[0].coordinates.x, _array[0].coordinates.y);
  endShape();
}</code></pre>
      <h4>Adding Perlin Noise</h4>
      <p>
        The points that form the circle move by using noise values. The cosine and sine of <code>i</code>
        goes between -1 and 1 and this is mapped to a value ranging between 0 and <code>maxNoise</code> which in
        this sketch is set to 7. The third dimension of the noise space or <code>z</code> is incrementing and shows the Perlin Noise space
        over time. The <code>animatePoints()</code> function is called before <code>drawCurveVertices()</code> and updates
        the initial x and y positions of each point every time <code>draw()</code> runs. In the above sketch, I fade the black background
        by giving it an opacity.
      </p>
<pre><code class="language-js">function animatePoints() {
  points = [];
  z += 0.01;
  for (let i = 0; i < numOfSegments; i++) {
    let x = map(cos(i), -1, 1, 0, maxNoise);
    let y = map(sin(i), -1, 1, 0, maxNoise);
    let n = noise(x, y, z);
    let xPos = radius * cos(angle*i) * n;
    let yPos = radius * sin(angle*i) * n;
    points.push(new Point(xPos, yPos));
  }
}</code></pre>
    </article>
    <footer>
      <p>
          <strong>Jurizza Cuaresma</strong><br/>
          <a href="../../index.html">Home</a> &#8725; 
          <a href="mailto:jurizzarc@gmail.com">Contact</a> &#8725;
          <a href="https://github.com/jurizzarc/creative-coding">GitHub</a>
      </p>
    </footer>
  </main>

  <!-- Syntax Highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <!-- P5 sketch -->
  <script src="../../libraries/p5/p5.min.js" type="text/javascript"></script>
  <script src="../../libraries/p5/p5.dom.min.js" type="text/javascript"></script>
  <script src="preview.js" type="text/javascript"></script>
</body>

</html>